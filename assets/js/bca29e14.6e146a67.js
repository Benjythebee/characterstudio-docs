"use strict";(self.webpackChunkcharacterstudio_docs=self.webpackChunkcharacterstudio_docs||[]).push([[2134],{2331:(e,s,n)=>{n.r(s),n.d(s,{assets:()=>r,contentTitle:()=>c,default:()=>h,frontMatter:()=>o,metadata:()=>i,toc:()=>l});var t=n(4848),a=n(8453);const o={},c="Create",i={id:"Developers/Pages/create",title:"Create",description:"In layman's terms, this code defines a component in a React application that allows users to select a character class for a game. The component fetches a list of available classes from a context, displays them in a scrollable container, and allows the user to select a class. If the class is disabled, the user cannot select it. When a class is selected, the component fetches additional information about the class and transitions to a different view. The component also plays different sounds based on user interactions, if the sound is not muted.",source:"@site/docs/Developers/Pages/create.md",sourceDirName:"Developers/Pages",slug:"/Developers/Pages/create",permalink:"/characterstudio-docs/docs/Developers/Pages/create",draft:!1,unlisted:!1,editUrl:"https://github.com/m3-org/characterstudio-docs/tree/main/docs/Developers/Pages/create.md",tags:[],version:"current",frontMatter:{},sidebar:"tutorialSidebar",previous:{title:"Bio",permalink:"/characterstudio-docs/docs/Developers/Pages/bio"},next:{title:"Landing",permalink:"/characterstudio-docs/docs/Developers/Pages/landing"}},r={},l=[];function d(e){const s={code:"code",h1:"h1",p:"p",pre:"pre",strong:"strong",...(0,a.R)(),...e.components};return(0,t.jsxs)(t.Fragment,{children:[(0,t.jsx)(s.h1,{id:"create",children:"Create"}),"\n",(0,t.jsx)(s.p,{children:"In layman's terms, this code defines a component in a React application that allows users to select a character class for a game. The component fetches a list of available classes from a context, displays them in a scrollable container, and allows the user to select a class. If the class is disabled, the user cannot select it. When a class is selected, the component fetches additional information about the class and transitions to a different view. The component also plays different sounds based on user interactions, if the sound is not muted."}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Import Statements"})}),"\n",(0,t.jsx)(s.p,{children:"The component imports necessary modules and contexts at the beginning. These include React hooks, CSS styles, and several contexts that provide shared state across the application."}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-jsx!",children:'import React, { useEffect, useState } from "react"\nimport styles from "./Create.module.css"\nimport { ViewMode, ViewContext } from "../context/ViewContext"\nimport CustomButton from "../components/custom-button"\nimport { LanguageContext } from "../context/LanguageContext"\nimport { useContext } from "react"\nimport { SceneContext } from "../context/SceneContext"\nimport { SoundContext } from "../context/SoundContext"\nimport { AudioContext } from "../context/AudioContext"\n'})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Create Function Component"})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"Create"})," function component takes a ",(0,t.jsx)(s.code,{children:"fetchCharacterManifest"})," function as a prop. This function is used to fetch additional information about a class when it is selected."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-jsx!",children:"function Create({fetchCharacterManifest}) {\n  ...\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"State and Contexts"})}),"\n",(0,t.jsxs)(s.p,{children:["The component uses several pieces of state and context. The ",(0,t.jsx)(s.code,{children:"useState"})," hook is used to manage the ",(0,t.jsx)(s.code,{children:"classes"})," state, which is an array of available classes. The ",(0,t.jsx)(s.code,{children:"useContext"})," hook is used to access shared state from the ",(0,t.jsx)(s.code,{children:"ViewContext"}),", ",(0,t.jsx)(s.code,{children:"SoundContext"}),", ",(0,t.jsx)(s.code,{children:"AudioContext"}),", and ",(0,t.jsx)(s.code,{children:"SceneContext"}),"."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-jsx!",children:"const {t} = useContext(LanguageContext);\nconst { setViewMode } = React.useContext(ViewContext)\nconst { playSound } = React.useContext(SoundContext)\nconst { isMute } = React.useContext(AudioContext)\nconst { manifest } = React.useContext(SceneContext)\nconst [ classes, setClasses ] = useState([]) \n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"useEffect Hook"})}),"\n",(0,t.jsxs)(s.p,{children:["The ",(0,t.jsx)(s.code,{children:"useEffect"})," hook is used to update the ",(0,t.jsx)(s.code,{children:"classes"})," state whenever the ",(0,t.jsx)(s.code,{children:"manifest"})," context changes. The ",(0,t.jsx)(s.code,{children:"manifest"})," context contains information about the available classes."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-jsx!",children:"useEffect(() => {\n  if (manifest != null){\n    const manifestClasses = manifest.map((c) => {\n      return {\n        name:c.name, \n        image:c.portrait, \n        description: c.description,\n        manifest: c.manifest,\n        icon:c.icon,\n        format:c.format,\n        disabled:false\n      }\n    })\n    setClasses(manifestClasses);\n  }\n}, [manifest])\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Event Handlers"})}),"\n",(0,t.jsxs)(s.p,{children:["The component defines several event handlers for user interactions. The ",(0,t.jsx)(s.code,{children:"back"})," function is called when the user wants to go back to the previous view. The ",(0,t.jsx)(s.code,{children:"selectClass"})," function is called when the user selects a class. The ",(0,t.jsx)(s.code,{children:"hoverClass"})," function is called when the user hovers over a class."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-jsx!",children:"const back = () => {\n  setViewMode(ViewMode.LANDING)\n  !isMute && playSound('backNextButton');\n}\n\nconst selectClass = (index) => {\n  fetchCharacterManifest(index).then(()=>{\n      setViewMode(ViewMode.APPEARANCE)\n  })\n  !isMute && playSound('classSelect');\n}\nconst hoverClass = () => {\n  !isMute && playSound('classMouseOver');\n}\n"})}),"\n",(0,t.jsx)(s.p,{children:(0,t.jsx)(s.strong,{children:"Render Method"})}),"\n",(0,t.jsxs)(s.p,{children:["The render method returns the JSX that defines the component's UI. It maps over the ",(0,t.jsx)(s.code,{children:"classes"})," state to create a list of class options. Each class option is a ",(0,t.jsx)(s.code,{children:"div"})," that displays the class's image, icon, name, and description. If the class is disabled, it cannot be clicked or hovered over."]}),"\n",(0,t.jsx)(s.pre,{children:(0,t.jsx)(s.code,{className:"language-jsx!",children:'return (\n  <div className={`${styles.container} horizontalScroll`}>\n    ...\n    <div className={styles.classContainer}>\n      {classes.map((characterClass, i) => {\n        return (\n          <div\n            key={i}\n            className={\n              !characterClass["disabled"]\n                ? styles.class\n                : styles.classdisabled\n            }\n            onClick={\n              characterClass["disabled"]\n                ? null\n                : () => selectClass(i)\n            }\n            onMouseOver={\n              characterClass["disabled"]\n                ? null\n                : () => hoverClass()\n            }\n          >\n          ...\n          </div>\n        )\n      })}\n    </div>\n    ...\n  </div>\n)\n'})})]})}function h(e={}){const{wrapper:s}={...(0,a.R)(),...e.components};return s?(0,t.jsx)(s,{...e,children:(0,t.jsx)(d,{...e})}):d(e)}},8453:(e,s,n)=>{n.d(s,{R:()=>c,x:()=>i});var t=n(6540);const a={},o=t.createContext(a);function c(e){const s=t.useContext(o);return t.useMemo((function(){return"function"==typeof e?e(s):{...s,...e}}),[s,e])}function i(e){let s;return s=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:c(e.components),t.createElement(o.Provider,{value:s},e.children)}}}]);